import pathlib
import os
import csv
import json
import numpy
import fnmatch
from tomo.models import  Dataset, Model
import shutil

class FilesManagement(object):
    """This class is used by the other classes whenever they need to manage files."""
    
    @staticmethod
    def build_path(nombre_file):
        path_actual = str(pathlib.Path(__file__).parent.absolute())
        path_completo = path_actual + "/" + nombre_file
        return path_completo


    @staticmethod
    def build_path_directory(nombre_file, username):
        """It returns the full path to a user's directory, concatenating at the end the filename 
        passed as the first argument."""

        path_generico = pathlib.Path(__file__).parent.parent
        path_completo = os.path.join(path_generico, 'users_directory', username, nombre_file)
        return path_completo



    @staticmethod
    def build_path_images(nombre_file):
        """It returns the path where the temporary images are stored, concatenating the filename at the end."""

        path_generico = pathlib.Path(__file__).parent.parent
        path_images = str(path_generico) + "/media/images/" + nombre_file

        return path_images



    @staticmethod
    def path_eidors():
        path_generico = pathlib.Path(__file__).parent.parent
        path_eidors = os.path.join(path_generico, 'eidors-v3.9.1-ng', 'eidors', 'startup.m')
        return path_eidors



    @staticmethod
    def build_path_model(id_model):
        path_generico = pathlib.Path(__file__).parent.parent
        path_models = os.path.join(path_generico, 'models', str(id_model))
        return path_models



    @staticmethod
    def build_path_datasets(nombre_file):
        path_generico = pathlib.Path(__file__).parent.parent
        path_images = str(path_generico) + "/media/datasets/" + nombre_file

        return path_images


    @staticmethod
    def read_full_file(nombre_file):
        '''Reads a file containing in each line 208 voltage values and 844 conductivity values. 
        It returns a list with the voltage and conductivity values.
        '''
        list_completa = []
        with open(FilesManagement.build_path(nombre_file)) as csvfile:
            file = csv.reader(csvfile, delimiter=';')
            for fila in file:
                list_completa.append(fila)
        list_completa = numpy.array(list_completa).astype('float32')
        list_voltages = list_completa[:,0:208]
        list_impedancia = list_completa[:,208:]

        return list_voltages,list_impedancia



    @staticmethod
    def read_coordinates():
        coordenadas = []
        with open(FilesManagement.build_path("x-y.csv")) as f:
            file_entrada = csv.reader(f, delimiter=',')
            for fila in file_entrada:
                coordenadas.append(fila)

        coordenadas = coordenadas[1:] #La primera línea es el header
        coordenadas = numpy.array(coordenadas).astype('float32')

        return coordenadas


    @staticmethod
    def remove_images(username):
        """It deletes all images created by the user during the session."""

        list_files = os.listdir(FilesManagement.build_path_images("")) #Obtengo los files del directory de imágenes
        files_remove = fnmatch.filter(list_files, "*_" + username + ".png")
        files_remove_cuts = fnmatch.filter(list_files, "cuts_" + username + "_?????????????.png")

        for f in files_remove:
            os.remove(FilesManagement.build_path_images(f))
        for f in files_remove_cuts:
            os.remove(FilesManagement.build_path_images(f))
            


    @staticmethod
    def clean_user_directory(username):
        """It removes all auxiliary files generated by the user during the session."""

        files_remove = os.listdir(FilesManagement.build_path_directory("", username)) #Obtengo los files del directory modulo_IA
        
        for f in files_remove:
            nombre_file = FilesManagement.build_path_directory(f, username)
            if(os.path.isfile(nombre_file)):
                os.remove(nombre_file)
            else:
                shutil.rmtree(nombre_file)



    @staticmethod
    def remove_files(username):
        """It removes both auxiliary files and images."""

        FilesManagement.remove_images(username)
        FilesManagement.clean_user_directory(username)
        



    @staticmethod
    def remove_model_file(id):
        """It removes the auxiliary file associated with the loading of a model."""

        type_model = Model.objects.get(id = id).type
        if type_model == "DNN":
            path_model = FilesManagement.build_path_model(id)
            path_json = path_model + ".json"
            path_h5 = path_model + ".h5"
            os.remove(path_json)
            os.remove(path_h5)
        else:
            path_model = FilesManagement.build_path_model(id) + ".joblib"
            os.remove(path_model)

        


    @staticmethod
    def generate_dataset_file(dataset_id, username):
        """It generates a file with the information of a dataset when the user selects the option to download it."""

        dataset = Dataset.objects.get(id = dataset_id)
        list_voltages = dataset.get_voltages()
        list_conductivities = dataset.get_conductivities()
        lineas = list(map(lambda x,y: x + y, list_voltages, list_conductivities))
        nombre_file = FilesManagement.build_path_datasets(username + "_dataset" + str(dataset_id) + ".csv")
        
        with open(nombre_file, "w") as f:
            writer = csv.writer(f, delimiter = ";")
            writer.writerows(lineas)



    @staticmethod
    def create_directory(username):
        """It creates a directory for a new user."""
        path_generico = pathlib.Path(__file__).parent.parent
        path_completo = os.path.join(path_generico, 'users_directory', username)
        try:
            os.mkdir(path_completo)
        except FileExistsError:
            print("File already exists.")



    @staticmethod
    def remove_file_individual(username, nombre_file):
        """It deletes a particular file from a particular user."""
        
        nombre_file = FilesManagement.build_path_directory(nombre_file, username)
        if(os.path.isfile(nombre_file)):
            os.remove(nombre_file)
        else:
            shutil.rmtree(nombre_file)

    

    @staticmethod
    def create_temporal_dataset_dir(id_dataset):
        """Creates a temporary directory when the user downloads a dataset."""
        dataset = Dataset.objects.get(id = id_dataset)
        path_generico = pathlib.Path(__file__).parent.parent
        path_completo = os.path.join(path_generico, 'users_directory', dataset.creator.get_username(), "dataset" + str(dataset.id))
        try:
            os.mkdir(path_completo)
        except FileExistsError:
            print("File already exists.")
            


    @staticmethod
    def build_path_dir_dataset(dataset, nombre_file):
        """It returns the path of a temporary directory for a dataset."""
        path_generico = pathlib.Path(__file__).parent.parent
        path_completo = os.path.join(path_generico, 'users_directory', dataset.creator.get_username(), "dataset" + str(dataset.id), nombre_file)
        return path_completo


    @staticmethod
    def build_path_modC(nombre_file):
        path_generico = pathlib.Path(__file__).parent.parent
        path_completo = os.path.join(path_generico, 'modulo_C', nombre_file)
        return path_completo



    @staticmethod
    def order_files(l, extension):
        lm = [int(s[:-4]) for s in l]
        lm.sort()
        lm2 = [str(n) + extension for n in lm]
        return lm2


    @staticmethod
    def read_voltages_conductivities(dataset):
        """It reads voltages and conductivities from the files generated by the C++ module and generates 
        two lists, which it returns."""

        list_voltages = []
        list_conductivities = []
        for n_obj in range(1,4): # Nº de objects
            n_a = 0
            n_b = 0
            for n_rad in range(dataset.min_radius,dataset.max_radius + 1): # Tamaño de radio
                sub_path =  "forwardModel/{}obj/{}".format(str(n_obj), str(n_rad))
                path_radio_voltages = FilesManagement.build_path_dir_dataset(dataset,sub_path) 
                files_csv = os.listdir(path_radio_voltages)
                files_csv.sort()

                n_a = n_a + len(files_csv)
                for f in files_csv:
                    f_completo = os.path.join(path_radio_voltages, f)
                    with open(f_completo, 'r') as f_csv:
                        file = csv.reader(f_csv, delimiter=';') #Lee una única línea, porque los files sólo tienen una línea.
                        list_voltages.append(list(file)[0])

                sub_path =  "meshes/{}obj/{}".format(str(n_obj), str(n_rad))
                path_radio_conductivities = FilesManagement.build_path_dir_dataset(dataset,sub_path) 
                files_out = os.listdir(path_radio_conductivities)
                files_out.sort()

                n_b = n_b + len(files_out)
                for f in files_out:
                    f_completo = os.path.join(path_radio_conductivities, f)
                    with open(f_completo, 'r') as f_out:
                        data = f_out.readlines()                        
                        list_conductivities.append(data[4687:5531])

        return list_voltages,list_conductivities



    @staticmethod
    def read_set_voltages(file, username):
        direc = FilesManagement.build_path_directory("set_voltages.csv", username)
        with open(direc, 'wb+') as destino:
            #for chunk in f.chunks():
            destino.write(file.read())

        list_voltages = []
        with open(direc, "r") as csvfile:
            file = csv.reader(csvfile, delimiter=';')
            for fila in file:
                list_voltages.append(fila)

        list_voltages = numpy.array(list_voltages).astype('float32')
        return list_voltages



    @staticmethod
    def write_predictions(username, voltages, predicted_conductivities):
        voltages = [list(v) for v in voltages]
        predicted_conductivities = [list(i) for i in predicted_conductivities]
        list_escribir = list(map(lambda x,y: x + y, voltages, predicted_conductivities))
        nombre_file = FilesManagement.build_path_directory("predictions.csv", username)
        with open(nombre_file, "w") as f:
            writer = csv.writer(f, delimiter = ";")
            writer.writerows(list_escribir)


    @staticmethod
    def read_predictions(username):
        list_completa = []
        nombre_file = FilesManagement.build_path_directory("predictions.csv", username)
        

        with open(nombre_file, "r") as csvfile:
            file = csv.reader(csvfile, delimiter=';')
            #
            for fila in file:
                list_completa.append(fila)
        list_completa = numpy.array(list_completa).astype('float32')

        list_impedancia = list_completa[:,208:]
        list_impedancia = list(list_impedancia)
        list_impedancia = [list(imp) for imp in list_impedancia]

        return list_impedancia

    @staticmethod
    def remove_dataset_directory(username, id_dataset):
        """It deletes the temporary directory created for a dataset download."""

        path_generico = pathlib.Path(__file__).parent.parent
        ruta_dataset = os.path.join(path_generico, 'users_directory', username, "dataset" + str(id_dataset) + "/")
        
        shutil.rmtree(ruta_dataset, ignore_errors=True)

    


    @staticmethod
    def remove_surplus_meshes(dataset, s1,s2,s3):
        """It removes unnecessary files that are created during the generation of a dataset."""

        raiz =  FilesManagement.build_path_dir_dataset(dataset,"{}/{}obj/{}/1.{}")   # 1. porque removeé la primera mesh de cada carpeta en la que sea necesario
        for i in range(s1):
            os.remove(raiz.format("meshes", str(1), str(4+i), "out"))
            os.remove(raiz.format("forwardModel", str(1), str(4+i), "csv"))
        for i in range(s2):
            os.remove(raiz.format("meshes", str(2), str(4+i), "out"))
            os.remove(raiz.format("forwardModel", str(2), str(4+i), "csv"))
        for i in range(s3):
            os.remove(raiz.format("meshes", str(3), str(4+i), "out"))
            os.remove(raiz.format("forwardModel", str(3), str(4+i), "csv"))
   


    @staticmethod
    def check_length(list_voltages, longitud):
        """It checks if the length of each line of a voltage file matches the length specified 
        as the second parameter."""

        list_bool = map(lambda x: (len(x) == longitud), list_voltages)
        mismas = all(list_bool)

        return mismas



    @staticmethod
    def validate_structure_file_voltages(list_voltages, n_elec = 16, p_estim = "adyacente"):
        """It checks that a voltage file contains in each line the appropriate structure."""

        structure_correcta = False

        if int(n_elec) == 16 and str(p_estim) == "adyacente":
            structure_correcta = FilesManagement.check_length(list_voltages, 208)

        return structure_correcta


    def read_sagetomo_email_account():
        generic_path = pathlib.Path(__file__).parent.parent
        full_path = os.path.join(generic_path, "passwords.json")

        with open(full_path) as f:
            data = json.load(f)
        
        pw = data["email"]

        return pw
  




    